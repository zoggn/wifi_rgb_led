// Видеообзоры и уроки работы с ARDUINO и ESP8266 на YouTube-канале IOMOIO: http://iomoio.ru

// О том как прошить файловую систему ESP8266 рассказываю в этом видео: https://youtu.be/UJo2G2Fe4ks﻿

#include <ESP8266WiFi.h>                // Библиотека для создания Wi-Fi подключения (клиент или точка доступа) 
#include <ESP8266WebServer.h>           // Библиотека для управления устройством по HTTP (например из браузера)
#include <ESP8266SSDP.h>                // Библиотека для обнаружения и отображения устройства в сетевом окружении 
#include <FS.h>                         // Библиотека для работы с файловой системой (SPIFS) ESP8266

ESP8266WebServer HTTP(80);              // Определяем объект и порт сервера для работы с HTTP

String AP       = "........";           // Здесь храним название точки доступа (роутера), к которой будем подключаться
String PASSWORD = "............";       // Здесь храним пароль для подключения к точке доступа (роутеру)

String SSDP_Name = "RGB_Lamp";          // Здесь определяем название устройства в сетевом окружении

#define r 2                             // Пин подключения красного
#define g 0                             // Пин подключения зеленого
#define b 3                             // Пин подключения синего (RX - 3-й пин)
#define button 1                        // Пин подключения кнопки (вывод стягивается к земле резистором) (TX - 1-й пин)

int ledmode = 1;                        // Переменная для изменения режимов работы светильника. Изначально устанавливаем в первый режим.
int cr,cg,cb;                           // Переменные для хранения текущих значений цветов (от 0 до 255 для каждого цвета)

int active_color;                       // Объявляем целочисленную переменную для перебора цветов (выбора цвета для обработки)
int i;                                  // Целочисленная переменная для плавной смены цветов (будет меняться от 0 до 255 и обратно)
boolean turn = true;                    // Объявляем логическую переменную для определения направления изменения спектра (true - в сторону увеличения значения к 255, false - в сторону уменьшения к 0)

void setup() {
  pinMode(r,OUTPUT);                        // Определяем пин подключения красного, как исходящий
  pinMode(g,OUTPUT);                        // Определяем пин подключения зеленого, как исходящий
  pinMode(b,OUTPUT);                        // Определяем пин подключения синего, как исходящий
  pinMode(button,INPUT);                    // Определяем пин подключения кнопки, как входящий

  analogWrite(r,invert(255));               // Отключаем красный
  analogWrite(g,invert(0));                 // Отключаем зеленый
  analogWrite(b,invert(0));                 // Отключаем синий

  active_color = g;                         // Определяем цвет, с которого программа начнет работу (g - зеленый)
  i = 0;                                    // Определяем начальное значение для выбранного цвета

  WiFi.mode(WIFI_STA);                      // Определяем режим работы Wi-Fi модуля в режиме клиента
  WiFi.begin(AP.c_str(), PASSWORD.c_str()); // Подключаемся к точке доступа (роутеру)
  HTTP.begin();                             // Инициализируем Web-сервер
  SPIFFS.begin();                           // Инициализируем файловую систему
  SSDP_init();                              // Вызываем функцию инициализации SSDP (функция описана ниже)

// Далее описываем действия при наступлении того или иного HTTP-события 
  HTTP.on("/rainbow", [](){                   // При HTTP запросе вида http://адрес_устройства/rainbow
    ledmode = 1;                              //   переключаем светильник в первый режим
    HTTP.send(200, "text/plain", "rainbow");  //   отвечаем об успешной (код 200) обработке запроса текстом "rainbow"
  });
  HTTP.on("/red", [](){                       // При HTTP запросе вида http://адрес_устройства/red
    ledmode = 2;                              //   переключаем светильник во второй режим
    HTTP.send(200, "text/plain", "red");      //   отвечаем об успешной (код 200) обработке запроса текстом "red"
  });  
  HTTP.on("/orange", [](){                    // При HTTP запросе вида http://адрес_устройства/orange
    ledmode = 3;                              //   переключаем светильник в третий режим
    HTTP.send(200, "text/plain", "orange");   //   отвечаем об успешной (код 200) обработке запроса текстом "orange"
  });
  HTTP.on("/yellow", [](){                    // При HTTP запросе вида http://адрес_устройства/yellow
    ledmode = 4;                              //   переключаем светильник в четвертый режим
    HTTP.send(200, "text/plain", "yellow");   //   отвечаем об успешной (код 200) обработке запроса текстом "yellow"
  });
  HTTP.on("/green", [](){                     // При HTTP запросе вида http://адрес_устройства/green
    ledmode = 5;                              //   переключаем светильник в пятый режим
    HTTP.send(200, "text/plain", "green");    //   отвечаем об успешной (код 200) обработке запроса текстом "green"
  });
  HTTP.on("/lightblue", [](){                 // При HTTP запросе вида http://адрес_устройства/lightblue
    ledmode = 6;                              //  переключаем светильник в шестой режим
    HTTP.send(200, "text/plain", "lightblue");//  отвечаем об успешной (код 200) обработке запроса текстом "lightblue"
  });
  HTTP.on("/blue", [](){                      // При HTTP запросе вида http://адрес_устройства/blue
    ledmode = 7;                              //   переключаем светильник в седьмой режим
    HTTP.send(200, "text/plain", "blue");     //   отвечаем об успешной (код 200) обработке запроса текстом "blue"
  });
  HTTP.on("/violet", [](){                    // При HTTP запросе вида http://адрес_устройства/violet
    ledmode = 8;                              //   переключаем светильник в восьмой режим
    HTTP.send(200, "text/plain", "violet");   //   отвечаем об успешной (код 200) обработке запроса текстом "violet"
  });
  HTTP.on("/white", [](){                     // При HTTP запросе вида http://адрес_устройства/white
    ledmode = 9;                              //   переключаем светильник в девятый режим
    HTTP.send(200, "text/plain", "white");    //   отвечаем об успешной (код 200) обработке запроса текстом "white"
  });
  
  HTTP.onNotFound([](){                                   // Описываем действия при событии "Не найдено"
    if(!handleFileRead(HTTP.uri()))                       // Если функция handleFileRead (описана ниже) возвращает значение false в ответ на поиск файла в файловой системе
      HTTP.send(404, "text/plain", "File isn't found");   // возвращаем на запрос текстовое сообщение "File isn't found" с кодом 404 (не найдено)
  });
}

void loop() {
  HTTP.handleClient();                        // Обработчик HTTP-событий (отлавливает HTTP-запросы к устройству и обрабатывает их в соответствии с выше описанным алгоритмом)
  if (digitalRead(button) == HIGH && debounce()) {  // Если на контакте кнопки высокий сигнал и обработчик дребезга возвращает true,
   ledmode++;                                 // переключаем режим работы на следующий        
   if (ledmode > 9)                           //  Если значение режима работы больше максимального (их всего 9)
     ledmode = 1;                             //    Переключаем в первый режим
  }
  if (ledmode == 9)                           // Если светильник работает в девятом режиме, то
    smooth_white();                           //  вызываем функцию smooth_white() - для работы с белым свечением
  else                                        // иначе
    smooth_change();                          //  вызываем функцию smooth_change() - для работы с другими цветами и режимами
  delay(5);                                   // Задержка в 5 мс - общая для цикла loop
}

bool handleFileRead(String path){                       // Функция работы с файловой системой
  if(path.endsWith("/")) path += "index.htm";           // Если устройство вызывается по корневому адресу, то должен вызываться файл index.htm (добавляем его в конец адреса)
  String contentType = getContentType(path);            // С помощью функции getContentType (описана ниже) определяем по типу файла (в адресе обращения) какой заголовок необходимо возвращать по его вызову
  String pathWithGz = path + ".gz";                     // Заводим еще один путь с адресом заархивированной версии файла из адреса обращения
  if(SPIFFS.exists(pathWithGz) || SPIFFS.exists(path)){ // Если в файловой системе существует заархивированный или простой файл по адресу обращения
    if(SPIFFS.exists(pathWithGz))                       //  Если существует заархивированный файл,
      path += ".gz";                                    //    то добавляем в адрес обращения окончание, указывающее на архив
    File file = SPIFFS.open(path, "r");                 //  Открываем файл для чтения
    size_t sent = HTTP.streamFile(file, contentType);   //  Выводим содержимое файла по HTTP, указывая заголовок типа содержимого contentType
    file.close();                                       //  Закрываем файл
    return true;                                        //  Завершаем выполнение функции, возвращая результатом ее исполнения true (истина)
  }
  return false;                                         // Завершаем выполнение функции, возвращая результатом ее исполнения false (если не обработалось предыдущее условие)
}

String getContentType(String filename){                                 // Функция, возвращающая необходимый заголовок типа содержимого в зависимости от расширения файла
  if (HTTP.hasArg("download")) return "application/octet-stream";       // Если HTTP имеет аргументом "download", то отдаем содержимое файла для скачивания и завершаем выполнение функции 
  else if (filename.endsWith(".htm")) return "text/html";               // Если файл заканчивается на ".htm", то возвращаем заголовок "text/html" и завершаем выполнение функции
  else if (filename.endsWith(".html")) return "text/html";              // Если файл заканчивается на ".html", то возвращаем заголовок "text/html" и завершаем выполнение функции
  else if (filename.endsWith(".css")) return "text/css";                // Если файл заканчивается на ".css", то возвращаем заголовок "text/css" и завершаем выполнение функции
  else if (filename.endsWith(".js")) return "application/javascript";   // Если файл заканчивается на ".js", то возвращаем заголовок "application/javascript" и завершаем выполнение функции
  else if (filename.endsWith(".png")) return "image/png";               // Если файл заканчивается на ".png", то возвращаем заголовок "image/png" и завершаем выполнение функции
  else if (filename.endsWith(".gif")) return "image/gif";               // Если файл заканчивается на ".gif", то возвращаем заголовок "image/gif" и завершаем выполнение функции
  else if (filename.endsWith(".jpg")) return "image/jpeg";              // Если файл заканчивается на ".jpg", то возвращаем заголовок "image/jpeg" и завершаем выполнение функции
  else if (filename.endsWith(".ico")) return "image/x-icon";            // Если файл заканчивается на ".ico", то возвращаем заголовок "image/x-icon" и завершаем выполнение функции
  else if (filename.endsWith(".xml")) return "text/xml";                // Если файл заканчивается на ".xml", то возвращаем заголовок "text/xml" и завершаем выполнение функции
  else if (filename.endsWith(".pdf")) return "application/x-pdf";       // Если файл заканчивается на ".pdf", то возвращаем заголовок "application/x-pdf" и завершаем выполнение функции
  else if (filename.endsWith(".zip")) return "application/x-zip";       // Если файл заканчивается на ".zip", то возвращаем заголовок "application/x-zip" и завершаем выполнение функции
  else if (filename.endsWith(".gz")) return "application/x-gzip";       // Если файл заканчивается на ".gz", то возвращаем заголовок "application/x-gzip" и завершаем выполнение функции
  return "text/plain";                                                  // Если ни один из типов файла не совпал, то считаем что содержимое файла текстовое, отдаем соответствующий заголовок и завершаем выполнение функции
}

void SSDP_init(void) {                                                  // Функция формирующая описательные свойства устройства для его обнаружения в сетевом окружении
  HTTP.on("/description.xml", HTTP_GET, []() {                          // Если происходит обращение к файлу /description.xml в корне устройства
    SSDP.schema(HTTP.client());                                         // Создаем SSDP-схему описания устройства
  });
  SSDP.setDeviceType("upnp:rootdevice");                                // Тип устройства 
  SSDP.setSchemaURL("description.xml");                                 // Файл с описанием
  SSDP.setHTTPPort(80);                                                 // Порт работы с HTTP
  SSDP.setName(SSDP_Name);                                              // Нзвание устройства в сетевом окружении
  SSDP.setSerialNumber(ESP.getChipId());                                // Серийный номер (для заполнения используем ID чипа ESP)
  SSDP.setURL("/");                                                     // Адрес по которому производится обращение к устройству при инициализации подключения
  SSDP.setModelName(SSDP_Name);                                         // Название модели устройства
  SSDP.setModelNumber("000000000001");                                  // Номер модели
  SSDP.setModelURL("http://iomoio.ru");                                 // Страница с описанием данной модели в Интернет
  SSDP.setManufacturer("IOMOIO");                                       // Производитель
  SSDP.setManufacturerURL("http://iomoio.ru");                          // Адрес сайта производителя
  SSDP.begin();                                                         // Отдаем сформированную SSDP-схему описания устройства
}

int invert(int value){                  // Функция преобразования значений
// Для светодиода с общим анодом будем инвертировать значения
  return map(value, 0, 255, 1023, 0);  // Возвращаем инвертированное преобразованное значение в место вызова функции

// Для светодиода с общим катодом инвертировать значения не надо
//return map(value, 0, 255 , 0, 1023);  // Возвращаем преобразованное значение в место вызова функции
}

void change_color() {   // Функция последовательного изменения работы с цветовыми каналами
  switch (active_color) {               // Условие смены активного цвета по спектру для светодиодов с общим анодом 
    case r:                             // В случае текущей работы с красным
      active_color = b;                 //  изменяем его на синий    
      return;                           //  и прерываем дальнейшую обработку условий
    case g:                             // В случае текущей работы с зеленым
      active_color = r;                 //  изменяем его на красный 
      return;                           //  и прерываем дальнейшую обработку условий
    case b:                             // В случае текущей работы с синим
      active_color = g;                 //  изменяем его на зеленый
      return;                           //  и прерываем дальнейшую обработку условий (прописывать не обязательно, т.к. это условие и так последнее)
  }
/*  Для светодиодов с общим катодом последовательность смены цветов по спектру другая
  switch (active_color) {               // Условие смены активного цвета по спектру для светодиодов с общим катодом  
    case r:                             // В случае текущей работы с красным
      active_color = g;                 //  изменяем его на зеленый    
      return;                           //  и прерываем дальнейшую обработку условий
    case g:                             // В случае текущей работы с зеленым
      active_color = b;                 //  изменяем его на синий 
      return;                           //  и прерываем дальнейшую обработку условий
    case b:                             // В случае текущей работы с синим
      active_color = r;                 //  изменяем его на красный
      return;                           //  и прерываем дальнейшую обработку условий (прописывать не обязательно, т.к. это условие и так последнее)
  }
*/
}

void smooth_white() {                   // Функция плавного включения белого
    if (cr == 255 && cg == 255 && cb == 255)  // Если светдиод уже горит белым
      return;                                 //  прерываем работу функции smooth_white
    if (cr < 255)                             // Если красный не горит на максимум
      cr++;                                   //  увеличиваем его значение
    if (cg < 255)                             // Если зеленый не горит на максимум
      cg++;                                   //  увеличиваем его значение
    if (cb < 255)                             // Если синий не горит на максимум
      cb++;                                   //  увеличиваем его значение
    analogWrite(r,invert(cr));                // Записываем увеличенное и преобразованное к диапазону значение красного в соответствующий вывод
    analogWrite(g,invert(cg));                // Записываем увеличенное и преобразованное к диапазону значение зеленого в соответствующий вывод
    analogWrite(b,invert(cb));                // Записываем увеличенное и преобразованное к диапазону значение синего в соответствующий вывод
}

void smooth_change() {                  // Функция плавной смены цвета

  if (ledmode == 2 && cr == 255 &&  cg == 0 && cb == 0)     // Если выбран красный режим, а диод и так горит красным, то
    return;                                                 //  прерываем дальнейшую работу с функцией smooth_change

  if (ledmode == 3 && cr == 255 &&  cg == 70 && cb == 0)    // Если выбран оранжевый режим, а диод и так горит оранжевым, то
    return;                                                 //  прерываем дальнейшую работу с функцией smooth_change

  if (ledmode == 4 && cr == 255 &&  cg == 255 && cb == 0)   // Если выбран желтый режим, а диод и так горит желтым, то
    return;                                                 //  прерываем дальнейшую работу с функцией smooth_change

  if (ledmode == 5 && cr == 147 &&  cg == 255 && cb == 0)   // Если выбран зеленый режим, а диод и так горит зеленым, то
    return;                                                 //  прерываем дальнейшую работу с функцией smooth_change

  if (ledmode == 6 && cr == 0 &&  cg == 255 && cb == 200)   // Если выбран голубой режим, а диод и так горит голубым, то
    return;                                                 //  прерываем дальнейшую работу с функцией smooth_change

  if (ledmode == 7 && cr == 0 &&  cg == 0 && cb == 255)     // Если выбран синий режим, а диод и так горит синим, то
    return;                                                 //  прерываем дальнейшую работу с функцией smooth_change

  if (ledmode == 8 && cr == 255 &&  cg == 0 && cb == 255)   // Если выбран фиолетовый режим, а диод и так горит фиолетовым, то
    return;                                                 //  прерываем дальнейшую работу с функцией smooth_change

  if (cr != 0 &&  cg != 0 && cb != 0) {                     // Если предыдущим режимом был выбран белый, то 
    cg--;                                                   //  Плавно гасим зеленый, уменьшая текущее запомненное значение (-- уменьшает текущее значение на 1)
    cb--;                                                   //  Плавно гасим синий, уменьшая текущее запомненное значение (-- уменьшает текущее значение на 1)
    analogWrite(g,invert(cg));                              //  Записываем измененное значение зеленого в соответствующий вывод, предварительно преобразовав его к необходимому диапазону
    analogWrite(b,invert(cb));                              //  Записываем измененное значение синего в соответствующий вывод, предварительно преобразовав его к необходимому диапазону
    turn = true;                                            //  Направление изменение цвета устанавливаем на возрастание (важно сделать к тому моменту, как погасим зеленый и синий)
    i = 0;                                                  //  Значение для текущего цветового канала ставим в 0 (важно сделать к тому моменту, как погасим зеленый и синий)
    active_color = g;                                       //  Определяем цветовой канал с которого начнем работу (важно сделать к тому моменту, как погасим зеленый и синий)
    return;                                                 //  Прерываем дальнейшую работу с функцией smooth_change
  }
  
  if (turn)                                                 // Если направление TRUE,
    i++;                                                    //    то увеличиваем яркость текущего канала
  else                                                      // иначе 
    i--;                                                    //    уменьшаем

  analogWrite(active_color,invert(i));      // Записываем преобразованное значение в вывод, соответствующий текущему активному цвету

  mem_current_colors();                     // Вызываем функцию, чтобы запомнить текущие значения на всех цветовых каналах

  if ((i == 255 && turn) || (i == 0 && !turn)) {  // Если достигнуло максимальное значение для цвета при увеличении или минимальное при уменьшении
    change_color();                               //  меняем текущий рабочий цвет
    turn = !turn;                                 //  и изменяем направление изменения значения
  }
}

void mem_current_colors() {                 // Функция для запоминания текущих значение цветов
  switch (active_color) {                   // В зависимости от значения текущего рабочего цвета
    case r:                                 //  Если красный,
      cr = i;                               //    запоминаем значение в соответствующую красному переменную
      return;                               //    и прерываем дальнейшую работу функции mem_current_colors
    case g:                                 //  Если зеленый,
      cg = i;                               //    запоминаем значение в соответствующую зеленому переменную
      return;                               //    и прерываем дальнейшую работу функции mem_current_colors
    case b:                                 //  Если синий,
      cb = i;                               //    запоминаем значение в соответствующую синему переменную
      return;                               //    и прерываем дальнейшую работу функции mem_current_colors (эта строка не обязательная, т.к. условие и так последнее)
  }  
}

bool debounce() {                           // Функция обработки нажатия кнопки с устранением дребезга
  int high_level = 0;                       //  Объявляем целочисленную переменную для подсчета сигналов высокого уровня на контакте кнопки 
  for (int n = 0; n < 100; n++) {           //  В цикле меняем значение переменной n от 0 до 100 с шагом 1 
    if (digitalRead(button) == HIGH)        //    Если на контакте кнопки высокий сигнал
      high_level++;                         //      Увеличиваем значение счетчика высоких сигналов на 1
  }
  if (high_level > 70) {                    //  Если значение счетчика высоких сигналов больше некоторого значения (70), то 
     delay(1000);                           //    Делаем задержку для избежания повторного срабатывания
     return true;                           //    И возвращаем значение true (истина), означающее, что нажатие на кнопку определено положительно
  }
  return false;                             //  Если предыдущее условие не сработало, то возвращаем false (ложь)
}

